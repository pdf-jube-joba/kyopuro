# h
解説はわからないけどコードがわからないのに動いてしまった。
ワーシャルフロイド法
```rust
let mut dist: Vec<Vec<usize>> = vec![vec![std::usize::MAX; n]; n];

for &(a, b, c) in &abc {
    dist[a][b] = c;
    dist[b][a] = c;
}

// for i in 0..n {
//     dist[i][i] = 0;
// }

for k in 0..n {
    for i in 0..n {
        for j in 0..n {
            dist[i][j] = std::cmp::min(dist[i][j], dist[i][k].saturating_add(dist[k][j]))
        }
    }
}
```

これってワーシャルフロイド法だとコメントの部分はコメントを外すべきなんだが、
コメントアウトしたら通る。

おそらく理由としてはもともとの問題を考えると、距離が C であって 2 本以上の辺を使った path が存在するかどうかで距離を測りたいというものだった。
なのでそこを考えるといいということだと思うけど。
よくわからなかったので、 `d[a][i] + d[i][b] <= c ` を filter した。

# i
解説がよくわからなかった。
とりあえず、考える部分文字列の取り方は"貪欲"にとって得られるものだけを考えるのだと思う。
というのも、 S = "abcb" のような文字列のときに dp は解説の定義だとどうなるかというと、
「 文字列 S の 1 文字目から i 文字目までの部分から得られる部分文字列のうち i 文字目は必ず使うようなものの個数」
なので、
$ dp[0] = \#\{emptystring\} $
$ dp[1] = \#\{"a"\} $
$ dp[2] = \#\{"a", "b"\} $
$ dp[3] = \#\{"ac", "c"\} $
$ dp[4] = \#\{"ab", "b", "bb"\}$
となるが、これの sum をとっても目的のものは得られない（重複しているから）

でもそれを加味しても全然わからない。
s = "aaa" では
$ dp[0] = \#\{emptystring\} $
$ dp[1] = \#\{"a"\} $
$ dp[2] = \#\{\} $
$ dp[3] = \#\{"aa"\} $
のようになってほしい。
そうすると、空の文字列に付け加える操作は普通に考えると別枠になるべき。
というのも、
$k$ を $k < i$ かつ $s[k] == s[i]$ となる最大のもの（ない場合は $0$ ）とする。
のはよいが、この後に $dp[i+1] = dp[j in k..i] + s[i]$ をするのはよくない。
以下の部分と整合性が取れない。
$dp[2] = (dp[0] = \{\} + 'a')$ となってはいけないが、
$dp[3] = (dp[1] = \{"a"\} + 'a')$ となるのは構わない。

