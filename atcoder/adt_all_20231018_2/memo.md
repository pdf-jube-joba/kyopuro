# i
Binary Indexed Tree を使うのが模範解答（転送数の計算だから）
BIT は [https://qiita.com/ngtkana/items/7d50ff180a4e5c294cb7] を参考にする。

- bit.sum が $[0..r)$ なのか $[0..r]$ なのかが一瞬ではわからなかった。
- color で元をわけたときに、 $color[c] < 2$ になっているやつは考える必要がない（これでTLEをちょっと減らせた。）
- さらに圧縮をするほうがかなりパフォーマンスが良い。（たしかにでかいものがくると大変だとは思うがここまで早くなるとは）

気になったこと：
- compress の実装は 例として、 $[2,1,5,2] -> [1,0,3,2]$ になることが保証されているのか？（同じ大きさの元が来た時に、圧縮後もその座標の関係が保たれているか）
    - $[2,1,5,2] -> [1,3,0,2]$ となるとだめで転倒数が異なる。
    - もしならないなら、誤った実装になっている。
