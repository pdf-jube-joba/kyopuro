# g
問題は `k: NN` に対して `min {n in NN | (k | n!)}` を求める。
（ `res(k)` としておく。）
素因数分解で `res(p^a)` の形がわかればいいとなる。
`(1..=a).map(|i| p * i).find(|n| (p^a | n!))` が求めるものになるが、
これはコストが重いので、前の `i` の結果を流用するべき。
`p: prime` に対して `f(n: NN) = max {a': NN | (p^(a') | n)}` とすれば、
求めるのは `(1..=a).map(|i| p * i).find(|n| f(n) == a)` である。
`f(a * b) = f(a) + f(b)` が成り立つ。
よって `f((p * i)!)` の求め方は
- `f((p * 0)!) = 0`
- `f((p * (i + 1))!) = f((p * i)!) + 1 + f(i+1)`
となる。
これの計算が模範解答にある部分になってるっぽい。
模範解答からそのまま rust にした。
```rust
fn f(p: usize, mut a: usize) -> usize {
    let mut n = 0;
    while a > 0 {
        n += p;
        let mut x = n;
        while x % p == 0 {
            x /= p;
            a -= 1;
        }
    }
    n
}
```
しかし、これではだめそうで、
c++ での回答では a が usize ではなく int になっているっぽい。
例として、 `f(2,5)` は `2^5 | 8!` で `8` が答えになるが、

なんか自分で書いた式と模範解答がそこまで対応してないかも。

ただこれ自体はやりかたがわかった。
`n = p * i` として `i=0` から順に `p^a` を数え上げていくらしい。

