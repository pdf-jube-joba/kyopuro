# 8 puzzle
## 内容
8 puzzle　を解けというもの

## メモ
とりあえず幅優先探索を用いることはわかった。
- はじめに考えた解き方：頂点から2 lenでいけるところ、3 len でいけるところと単に探索していく
- 次に考えた解き方：すでに通ったことのある頂点の列挙は無駄であるから、訪れた頂点をメモしておくことを考えた。
    - Memory limit exceed になった。

## 回答について
他人の回答を見ても何をやっているのかよくわからなかったが、適当な本を読んで理解した。
\(S_k\) を（頂点 \(x\) から）最短距離 \(k\) でいける頂点の集合とすると、 \(S_{k+1}\) は \(S_{k}\) と \(S_{k-1}\) のみを用いて計算できる。
具体的には、 \(S_{k}\) から \(1\) でいける頂点全体から \(S_{k-1}\) にふくまれる全体をひいた集合 \(S^{k+1}\) がちょうど \(S_{k+1}\) に一致しているからだ。 
（なぜなら、 \(x-y\) であって \(k+1\) でいける頂点 \(y\) を考えたとすると最短距離を実現している path から \(y\) の頂点を手前が \(S_{k}\) に入りそうなので（そうじゃなかったら矛盾する） \(S_{k+1} \subset S^{k+1}\) であり、 逆はもし \(=\) じゃなかったら、 \(y^\prime \ub S_{k}\) から \(1\) でいける距離に \(y\) があって \(y\) の最短距離が \(k-1\) 意外だったとすると、 \(k-1\) より大きい場合は \(y^\prime\) を通ればもっと最短距離が小さくできて矛盾し、 \(k-1\) より小さいときは逆に \(y\) を通って \(y^\prime\) に行けば \(y^\prime\) がもっと短い距離で行けることになるから矛盾する。）

それを用いてメモリ使用量を大幅に減らしているみたいだ。

# 15 puzzle
## 内容
15 puzzles を解けというもの

## メモ
とりあえず、 8 puzzle の内容を以下のように書き換えた。
- const を使って大域定数を設定してそれで書き換えた
- 構造体で Move を使って書き直した

もちろんMLEした。
他人の回答を参考にする

- dfs の方がよい？
    - 現在の盤面から"最低?手動かさないと解けない" がわかる。
    - 直前に戻る動かし方はしない
    - limit をつける
    - iterative deepening algorithm ? とすると、用いる関数が「最低でも？？かかる」を用いた探索になる
- cの早い提出は優先度付きキューとHashSetを使っている
    - へんな定数 magic を使って depth とマンハッタン距離で最良を選んでいる？
    - A-start algorithm ?
