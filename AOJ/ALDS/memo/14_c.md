# pattern search
## 内容
\(H \times W\) に並べられた文字がある。 \(R \times C\) 文字のパターンをその中から見つけたい

## メモ
Rolling hash を使う
\(r \times c\) 行列 \((a_{i,j})_ {0 \leq i < r, 0 \leq j < c}\) に対して、 \(b \in \mathbb{Z}\) での hash を \(H (a_ {i,j}) = \sum_{i,j} a_ {i,j} * b^{rc - c(i-1) - (j-1)}\) として定める。

これは、 \(a_{i,j}\) を横書きとして順番に並べるときに、 \(b^{*}\) の次数が順々に下がっていくように定めている。
i.e. \(a_{0,0} * b^{t} + a_{0,1} * b^{t-1} + ... + a_{0,c-1} * b^{\cdot} + a_{1,0} * b^{\cdot - 1} + a_{1,1} * b^{\cdot - 2} + ... + a_{r-1, c-1}^{0}\) となるように \(b^{*}\) の次数を決めた。

hash をかける部分を横に動かそうと、縦に動かそうと、 r や c 倍のコストがかかる？
縦部分を先に計算して入れておけば、計算が楽にできる？
\(A_{i,j} = (a_{i,j} ... a_{i+(r-1),j})^{\text{t}}\) なる縦部分の hash を \(H_{i,j} = \sum_{0 \leq k < r} a_{i+k,j} * b^{c * ((r-1) - k)}\) とする。

もう少し考えておきたい。
base \(b\) を固定しておく。
- let \(H\): \(M(r,c) \to \mathbb{Z}\) := \((a _{l,k}) \mapsto \sum _{0 \leq l < r, 0 \leq k < c} a _{l,k} * b^{r * c - c()}\)
- let \(h\): \(M(r, 1) \to \mathbb{Z}\) := \((a _{l,k}) \mapsto \sum _{0 \leq l < r, k} a _{l,k} * b^{c * (r-1 - k)}\)
- then \(H (a_{i,j}) = \sum_{0 \leq k < c} h (a_{i,j})_{0 \leq i < r, j = k} * b^{c-1-k}\)
- then for \(r \leq h\), \(c \leq w\), \((a_{i,j})\): \(M(h,w)\)
      - for \(0 \leq l < h-c\), \(0 \leq k < w\), it-holds \(H (a _{l+1+i,k+j}) _{i,j} = H (a _{l+i,k+j}) _{i,j} * b - h (a _{l + i,k}) * b^c + h (a _{l + c, k})\)
      - for \(0 \leq l < w\), \(0 \leq k < w-r\), it-holds \(h (a_{l+i, k+1+j}) = h (a_{l+i,k+j}) * b^c - a_{l,k} * b^{rc} + a_{l,k+r}\)
これが証明できればよさそう。
計算なので省く（多分大丈夫だろう）

1. 初めに \(H_{0,0},...,H_{0,w-1}\) を計算する。
   1. 各 \(H_{i,0}\) の計算量は \(O(r)\) になる。
2. \((a_{i,j})_{0 \leq i < r, 0 \leq j < c}\) のハッシュを \(H _{0,0}\) から \(H _{0,c-1}\) を使って計算する。 このコストは　\(O(c)\) になる。
3.  各 \(0 \leq k < w-c\) に対して \((a_{i+k,j}) _{0 \leq i < r, 0 \leq j < c}\) のハッシュを \(k-1\) で得られたハッシュと \(H _{0, k}\) をもとに計算する。このコストは \(O(1)\) になる。
4.  各 \(0 \leq k < w\) に対して \(H_{1,k}\) を \(H_{0,k}\) をもとに計算する。このコストは \(O(1)\) になる。
5. 2. に戻り \(a_{1,*}\) でのハッシュを計算する
