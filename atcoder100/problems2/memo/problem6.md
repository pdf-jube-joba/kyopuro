# 問題
前提
- $s$: 半角数字からなる長さ $n$ の文字列
---
求めるもの
- $\#\{m: \text{整数} \mid \text{\(m\) は三桁で \(s\) から \(3\)桁残して作ることができる}\}$
---
制約
- $4 \leq n \leq 30000$

# 方針
$m$ のありうる候補自体が $1000$ 通りしかないため、 $m$ をつくることができるかを全て調べればよい。
$m$ を $3$ 桁の数字ではなく長さの $3$ の配列と考えると、各 $m$ について次の問題を解けばよい。
「 $a$, $b$: 配列について $b$ から要素を削って $a$ と同じにできるか。」
これは貪欲法を用いて次のように書けばよい
- `b` を走査し、 `a[0]` をみつける
- `b` を `a[0]` が見つかった地点から走査し `a[1]` をみつける
- `b` を `a[1]` が見つかった地点から走査し `a[2]` をみつける
- ... `b` を `a[n-2]` が見つかった地点から走査し `a[n-1]` をみつける
以上の手続きの中で、途中で見つけることができずすべての `b` を走査することになったら false を返し、すべての手続きに成功したら true を返す。

# 実装
## 1
### 配列が作れるか判定
二つの配列 $a$, $b$ を受け取って $b$ から要素を削って $a$ が作れるか判定するのを次のように書いた。
```Rust
let removable = |a: &[usize], b: &[usize]| {
    let mut index = 0;
    for &i in b {
        if i == a[index] {index += 1;}
        if index == a.len() {return true;}
    }
    return false;
};
```
- for 文を一回回った後は次のような条件が保たれている（ `b` の要素 `i` が何番目かを `|i|` としておく。）
    - `a[..index]` は `b[..|i|]` の要素を削って作ることができる。

がこれは誤りであることが分かった。
（ `a`, `b` がともに空であるとき false が返されて正しくない実装である。）
正しくは次のように書くべき。
```Rust
let removable = |a: &[usize], b: &[usize]| {
    let mut j = 0;
    for &i in a {
        loop {
            if j == b.len() {return false;}
            if i == b[j] {break;}
            j += 1;
        }
        j +=1;
    }
    return true;
}
```
これはだいたい次の漸化式に従ってる。
- $f(a:\text{array}, b:\text{array}) = \text{\(\) を削って \(b\) を作れるか}$ とすると
    - $f([], \_) = \text{true}$
    - $f([a_0, \ldots], []) = \text{false}$
    - $f([a_0, \ldots, a_i],[b_0, \ldots, b_j]) = \text{if \(a_i = b_j\) then \(f([a_0, \ldots, a_{i-1}], [b_0, \ldots, b_{j-1}])\) else \(f([a_0, \ldots, a_{i}], [b_0, \ldots, b_{j-1}])\) }$

まずエラーが出ないかどうかはやばいのは `b[j]` へのアクセスだけだが、
- loop に入る前に $0 \leq j \leq b.\text{len}()$ が満たされているとき、 $j = b.\text{len}()$ なら return で抜けるから以降は $j < b.\text{len}()$ を仮定してよく、`b[j]` へアクセスしてよい。
- 次の条件式で loop を抜ける際も loop を抜けた後が `j += 1;` だけしか操作をしないので $j < b.\text{len}()$ だった条件が $j \leq b.\text{len}()$ になるので loop に入るときは常にこの条件が満たされている。

停止するかどうかは
- `j` に着目すれば loop を一周するごとに $1$ 大きくなるか、 loop を break して $1$ 大きくなって戻ってくるか、 $= b.\text{len}()$ になり return するかのいずれかなのでよい。

次に正しいかどうかは
- loop 時に成り立っている条件はさらに、
    - `|i| < a.len()`
    - `a[..|i|]` は `b[..j]` から要素を削って作れる
    - `a[..=|i|]` は `b[..j]` から要素を削っては作れない
- 一つ目の条件式のみが false を返しうるところであるが、1つめの条件と3つめの条件により `a[..=|i|]` は `b` を使って作ることができないため、ここで false が変えるなら確かに作ることができない
- loop を抜けるのは他には `break;` のみである。よってこの break に入る条件を見れば、loop を出た直後は `a[..=|i|]` が `b[..=j]` から作れることがわかる。
- なので for 文の中では回り始めは `a[..|i|]` は `b[..j]` から作ることができることが成り立っていて、回り終わりは `a[..=|i|]` は `b[..j]` からつくることができることが成り立っている。（ `j` は更新されたもの）
- ので for 文を終えてくると `a[..=a.len()]` が `b[..j]` からつくることができる状態になっている、のでよい。

### 全体
全体としては簡単で、次のようになった。
```Rust
let removable = |a: &[usize], b: &[usize]| {
    let mut j = 0;
    for &i in a {
        loop {
            if j == b.len() {return false;}
            if i == b[j] {break;}
            j += 1;
        }
        j += 1;
    }
    return true;
};
(0..1000)
.map(|num|{
    vec![(num  / 100) % 10, (num / 10) % 10, num % 10]
})
.filter(|num|{
    removable(num, a)
})
.count()
```
`(0..1000)` を三桁の配列にした。

# 計算量
## 1
removable が $a,b$ それぞれを同時に探索しているのでこの関数は $O(\text{max}(|a|, |b|))$ となる。
が、これを適用する際に $|a|$ は定数 $3$ で抑えられてしまう。
そのため、 $O(|num|)$ になると思う。